/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "gill";
import {
  type ParsedBurnAssetHandlerInstruction,
  type ParsedCreateCoreAssetHandlerInstruction,
  type ParsedCreateVaultCollectionHandlerInstruction,
  type ParsedInitNftProgramHandlerInstruction,
  type ParsedListAssetHandlerInstruction,
  type ParsedUnlistAssetHandlerInstruction,
} from "../instructions";

export const NFT_PROGRAM_PROGRAM_ADDRESS =
  "AkFAoXys2zhqE15q8XJJJRqXgxLdtJ1kb9ec4fCo1GgH" as Address<"AkFAoXys2zhqE15q8XJJJRqXgxLdtJ1kb9ec4fCo1GgH">;

export enum NftProgramAccount {
  BaseAssetV1,
  NFTConfig,
  Offer,
}

export function identifyNftProgramAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): NftProgramAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([1])),
      0,
    )
  ) {
    return NftProgramAccount.BaseAssetV1;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([92, 106, 11, 162, 250, 188, 6, 90]),
      ),
      0,
    )
  ) {
    return NftProgramAccount.NFTConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([215, 88, 60, 71, 170, 162, 73, 229]),
      ),
      0,
    )
  ) {
    return NftProgramAccount.Offer;
  }
  throw new Error(
    "The provided account could not be identified as a nftProgram account.",
  );
}

export enum NftProgramInstruction {
  BurnAssetHandler,
  CreateCoreAssetHandler,
  CreateVaultCollectionHandler,
  InitNftProgramHandler,
  ListAssetHandler,
  UnlistAssetHandler,
}

export function identifyNftProgramInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): NftProgramInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([184, 55, 221, 84, 149, 186, 37, 1]),
      ),
      0,
    )
  ) {
    return NftProgramInstruction.BurnAssetHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([86, 115, 142, 198, 201, 252, 198, 75]),
      ),
      0,
    )
  ) {
    return NftProgramInstruction.CreateCoreAssetHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([201, 227, 122, 178, 131, 228, 248, 113]),
      ),
      0,
    )
  ) {
    return NftProgramInstruction.CreateVaultCollectionHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([246, 11, 44, 229, 225, 212, 181, 44]),
      ),
      0,
    )
  ) {
    return NftProgramInstruction.InitNftProgramHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([78, 90, 204, 78, 80, 232, 145, 204]),
      ),
      0,
    )
  ) {
    return NftProgramInstruction.ListAssetHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([97, 27, 195, 138, 135, 193, 217, 48]),
      ),
      0,
    )
  ) {
    return NftProgramInstruction.UnlistAssetHandler;
  }
  throw new Error(
    "The provided instruction could not be identified as a nftProgram instruction.",
  );
}

export type ParsedNftProgramInstruction<
  TProgram extends string = "AkFAoXys2zhqE15q8XJJJRqXgxLdtJ1kb9ec4fCo1GgH",
> =
  | ({
      instructionType: NftProgramInstruction.BurnAssetHandler;
    } & ParsedBurnAssetHandlerInstruction<TProgram>)
  | ({
      instructionType: NftProgramInstruction.CreateCoreAssetHandler;
    } & ParsedCreateCoreAssetHandlerInstruction<TProgram>)
  | ({
      instructionType: NftProgramInstruction.CreateVaultCollectionHandler;
    } & ParsedCreateVaultCollectionHandlerInstruction<TProgram>)
  | ({
      instructionType: NftProgramInstruction.InitNftProgramHandler;
    } & ParsedInitNftProgramHandlerInstruction<TProgram>)
  | ({
      instructionType: NftProgramInstruction.ListAssetHandler;
    } & ParsedListAssetHandlerInstruction<TProgram>)
  | ({
      instructionType: NftProgramInstruction.UnlistAssetHandler;
    } & ParsedUnlistAssetHandlerInstruction<TProgram>);
