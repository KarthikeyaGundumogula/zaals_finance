/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from "gill";
import {
  type ParsedClaimBeneficiaryRewardsHandlerInstruction,
  type ParsedClaimInvestorRewardsHandlerInstruction,
  type ParsedClosePositionHandlerInstruction,
  type ParsedCloseVaultHandlerInstruction,
  type ParsedCreateSlasReqHandlerInstruction,
  type ParsedCreateVaultHandlerInstruction,
  type ParsedDepositRewardsHandlerInstruction,
  type ParsedFinalizeSlashReqHandlerInstruction,
  type ParsedInitCapitalProgramHandlerInstruction,
  type ParsedOpenPositionHandlerInstruction,
  type ParsedUpdatePositionHandlerInstruction,
} from "../instructions";

export const CAPITAL_PROGRAM_PROGRAM_ADDRESS =
  "8syRdGBunFUWZzkgGigv1KWcTEhxPkc15DMVXEYj9qVn" as Address<"8syRdGBunFUWZzkgGigv1KWcTEhxPkc15DMVXEYj9qVn">;

export enum CapitalProgramAccount {
  AuthorityConfig,
  BaseAssetV1,
  NFTConfig,
  Position,
  Vault,
}

export function identifyCapitalProgramAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): CapitalProgramAccount {
  const data = "data" in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([70, 68, 21, 32, 12, 21, 85, 159]),
      ),
      0,
    )
  ) {
    return CapitalProgramAccount.AuthorityConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 1).encode(new Uint8Array([1])),
      0,
    )
  ) {
    return CapitalProgramAccount.BaseAssetV1;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([92, 106, 11, 162, 250, 188, 6, 90]),
      ),
      0,
    )
  ) {
    return CapitalProgramAccount.NFTConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([170, 188, 143, 228, 122, 64, 247, 208]),
      ),
      0,
    )
  ) {
    return CapitalProgramAccount.Position;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([211, 8, 232, 43, 2, 152, 117, 119]),
      ),
      0,
    )
  ) {
    return CapitalProgramAccount.Vault;
  }
  throw new Error(
    "The provided account could not be identified as a capitalProgram account.",
  );
}

export enum CapitalProgramInstruction {
  ClaimBeneficiaryRewardsHandler,
  ClaimInvestorRewardsHandler,
  ClosePositionHandler,
  CloseVaultHandler,
  CreateSlasReqHandler,
  CreateVaultHandler,
  DepositRewardsHandler,
  FinalizeSlashReqHandler,
  InitCapitalProgramHandler,
  OpenPositionHandler,
  UpdatePositionHandler,
}

export function identifyCapitalProgramInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): CapitalProgramInstruction {
  const data = "data" in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([105, 195, 177, 247, 219, 87, 16, 160]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.ClaimBeneficiaryRewardsHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([6, 82, 210, 8, 150, 27, 95, 90]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.ClaimInvestorRewardsHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([119, 182, 102, 214, 62, 149, 56, 171]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.ClosePositionHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([189, 33, 201, 147, 218, 184, 7, 114]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.CloseVaultHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([105, 0, 66, 75, 41, 216, 177, 167]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.CreateSlasReqHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([166, 83, 111, 163, 111, 146, 16, 162]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.CreateVaultHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([186, 68, 103, 29, 158, 215, 213, 14]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.DepositRewardsHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([41, 86, 186, 238, 159, 13, 133, 102]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.FinalizeSlashReqHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([248, 187, 57, 89, 38, 219, 66, 222]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.InitCapitalProgramHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([58, 49, 185, 32, 232, 196, 248, 220]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.OpenPositionHandler;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([90, 239, 196, 216, 224, 38, 150, 31]),
      ),
      0,
    )
  ) {
    return CapitalProgramInstruction.UpdatePositionHandler;
  }
  throw new Error(
    "The provided instruction could not be identified as a capitalProgram instruction.",
  );
}

export type ParsedCapitalProgramInstruction<
  TProgram extends string = "8syRdGBunFUWZzkgGigv1KWcTEhxPkc15DMVXEYj9qVn",
> =
  | ({
      instructionType: CapitalProgramInstruction.ClaimBeneficiaryRewardsHandler;
    } & ParsedClaimBeneficiaryRewardsHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.ClaimInvestorRewardsHandler;
    } & ParsedClaimInvestorRewardsHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.ClosePositionHandler;
    } & ParsedClosePositionHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.CloseVaultHandler;
    } & ParsedCloseVaultHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.CreateSlasReqHandler;
    } & ParsedCreateSlasReqHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.CreateVaultHandler;
    } & ParsedCreateVaultHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.DepositRewardsHandler;
    } & ParsedDepositRewardsHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.FinalizeSlashReqHandler;
    } & ParsedFinalizeSlashReqHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.InitCapitalProgramHandler;
    } & ParsedInitCapitalProgramHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.OpenPositionHandler;
    } & ParsedOpenPositionHandlerInstruction<TProgram>)
  | ({
      instructionType: CapitalProgramInstruction.UpdatePositionHandler;
    } & ParsedUpdatePositionHandlerInstruction<TProgram>);
